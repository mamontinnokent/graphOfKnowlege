Современные процессоры (CPU) имеют несколько ядер, и некоторые поддерживают гиперпоточность, поэтому они могут обрабатывать несколько инструкций одновременно. Чтобы полностью утилизировать современные CPU, нужно использовать конкурентное программирование.

Конкурентные вычисления — это форма вычислений, когда несколько инструкций выполняются, пересекаясь, в течение одного временного периода.

Например есть 2 инструкции, которые нужно выполнить: `А` и `B`. При выполнении инструкций конкурентно ядро процессора вычисляет инструкцию `A`, при ожидающей `B`. Когда первая инструкция `A` заканчивает активное вычисление, она ставится на паузу, и ядро переключается на вычисление инструкции `B`.

Рассмотрим простой пример конкурентности в реальной жизни: HTTP запрос к стороннему сервису по сети:

-   вычисление `А` делает HTTP запрос
    
-   пока `А` ждет ответа, начинает выполняться вычисление B
    
-   когда ответ пришел, `А` возвращается в работу
    

Если в процессоре присутствует более одного ядра, обработка происходит параллельно. Возвращаясь к примеру выше, инструкции `A` и `B` будут выполняться независимо в один момент времени.

Конкурентные вычисления могут происходить в программе, компьютере или сети. В данном курсе рассматривается только уровень программ.

# Горутины

Вот и подошло время познакомиться с самой сильной стороной языка Go — горутинами. Горутины — это легковесные потоки, которые реализуют конкурентное программирование в Go. Их называют легковесными потоками, потому что они управляются рантаймом языка, а не операционной системой. Стоимость переключения контекста и расход памяти намного ниже, чем у потоков ОС. Следовательно, для Go — не проблема поддерживать одновременно десятки тысяч горутин.

Запустить функцию в горутине — супер легко. Для этого достаточно написать слово `go` перед вызовом функции:

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    // выведет сообщение в горутине
    go fmt.Println("Hello concurrent world")

    // если не подождать, то программа закончится, не успев, вывести сообщение
    time.Sleep(100 * time.Millisecond)
}
```

При написании конкурентного кода возникают новые моменты, которые нужно учитывать: состояние гонки, блокировки, коммуникация между горутинами. Пример программы, которая работает не так, как ожидается:

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    for i := 0; i < 5; i++ {
        go func() {
            fmt.Println(i)
        }()
    }

    time.Sleep(100 * time.Millisecond)
}
```

Сперва может показаться, что должны вывестись числа от 0 до 4, но на самом деле вывод будет следующим:

5
5
5
5
5

Все потому что `i` передается в общем скоупе, следовательно, когда горутины будут выполняться, цикл уже закончится и `i` будет равно 5. В данном случае нужно передать копию `i`:

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    for i := 0; i < 5; i++ {
        go func(i int) {
            fmt.Println(i)
        }(i)
    }

    time.Sleep(100 * time.Millisecond)
}
```

Вывод:

0
4
3
1
2

Также можно заметить, что числа вывелись не в порядке вызова. Горутины выполняются независимо и не гарантируют порядка. При необходимости последовательность в выполнении придется реализовывать самостоятельно.

# Каналы

В Go существует постулат: "Do not communicate by sharing memory; instead, share memory by communicating" (Не общайтесь разделением памяти. Разделяйте память через общение). Для безопасной коммуникации между горутинами используется специальный тип данных: `chan` (канал).

Как слайсы и мапы, каналы инициализируются с помощью функции `make`:

```go
numCh := make(chan int)
```

Чтение и запись в канал происходит через конструкцию ←. Стрелка ставится перед, если канал читается и после, если записывается:

```go
numCh := make(chan int)

numCh <- 10 // записали значение в канал

num := <- numCh // прочитали значение из канала и записали в переменную "num"
```

Чтение из канала блокирует текущую горутину, пока не вернется значение:

```go
package main

import (
    "fmt"
)

func main() {
    numCh := make(chan int)

    <-numCh // программа зависнет здесь и будет ошибка: fatal error: all goroutines are asleep - deadlock!

    fmt.Println("program has ended") // эта строка никогда не выведется
}
```

Запись в канал так же блокирует текущую горутину, пока кто-то не прочтет значение.

Каналы также можно использовать для задачи из прошлого урока:

```go
package main

import (
    "fmt"
)

func main() {
    fmt.Println(maxSum([]int{1, 2, 3}, []int{10, 20, 50})) // [10 20 50]
}

// суммирует значения каждого слайса nums и возвращает тот, который имеет наибольшую сумму
func maxSum(nums1, nums2 []int) []int {
    // канал для результата первой суммы
    s1Ch := make(chan int)
    go sumParallel(nums1, s1Ch)

    // канал для результата второй суммы
    s2Ch := make(chan int)
    go sumParallel(nums2, s2Ch)

    // присваиваем результаты в переменные. Здесь программа будет заблокирована, пока не придут результаты из обоих каналов.
    s1, s2 := <-s1Ch, <-s2Ch

    if s1 > s2 {
        return nums1
    }

    return nums2
}

func sumParallel(nums []int, resCh chan int) {
    s := 0
    for _, n := range nums {
        s += n
    }

    // результат суммы передаем в канал
    resCh <- s
}
```

Иногда требуется запустить обработчика в отдельной горутине, который будет выполнять работу на протяжении всего цикла жизни программы. С помощью конструкции `for range` можно читать из канала до того момента, пока он не будет закрыт:

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    // создаем канал, в который будем отправлять сообщения
    msgCh := make(chan string)

    // вызываем функцию асинхронно в горутине
    go printer(msgCh)

    msgCh <- "hello"
    msgCh <- "concurrent"
    msgCh <- "world"

    // закрываем канал
    close(msgCh)

    // и ждем, пока printer закончит работу
    time.Sleep(100 * time.Millisecond)
}

func printer(msgCh chan string) {
    // читаем из канала, пока он открыт
    for msg := range msgCh {
        fmt.Println(msg)
    }

    fmt.Println("printer has finished")
}
```