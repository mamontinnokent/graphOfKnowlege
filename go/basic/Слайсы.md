На практике не часто сталкиваешься с массивами из-за ограниченной длины при строгой типизации. Вместо этого повсеместно используются слайсы. Слайс — это массив неопределенной длины (или динамический массив):

```go
var nums = []int{1,2,3}

nums := []int{1,2,3}
```

Чтение и запись осуществляется точно так же как в массивах:

```go
nums := []int{1,2,3}

nums[2] // 3

nums[0] = 10 // [10, 2, 3]

nums[:2] // [10, 2]
```

В слайсы можно добавлять элементы с помощью встроенной функции `func append(slice []Type, elems …​Type) []Type`, которая возвращает новый слайс с добавленным элементом:

```go
words := []string{"hello"}

words = append(words, "world") // ["hello", "world"]
```

Так как слайс имеет нефиксированную длину, "под капотом" лежит более сложная структура, чем у массива. Помимо самих значений слайс хранит 2 дополнительных свойства: длину массива `len` (длина) и `cap` (вместимость). Благодаря этому возможно инициализировать слайс нужной длины с помощью встроенной функции `func make(t Type, len, cap IntegerType) Type`. Понимание, где лучше использовать какой способ инициализации, приходит с опытом, но для старта рекомендуется использовать `make` везде, где можно:

```go
// len = 5. Массив сразу будет заполнен 5-ю нулевыми значениями
nums := make([]int, 5, 5) // [0, 0, 0, 0, 0]

// len = 0, но cap = 5. Массив будет пустым, однако заполнение слайса через append будет эффективным, потому что в памяти уже выделен массив нужной длины
nums := make([]int, 0, 5) // []
```

Передача слайса как аргумента функции происходит хитро. Длина и вместимость передаются по значению, но массив значений передается по ссылке. Вследствие этого получается неявное поведение: добавленные элементы не сохранятся в исходный слайс, но изменение существующих останется:

```go
package main

import (
    "fmt"
)

func main() {
    nums := []int{1, 2, 3, 4, 5}

    modifySlice(nums)

    fmt.Println(nums) // [1 2 10 4 5]
}

func modifySlice(nums []int) {
    nums[2] = 10 // элемент будет и в исходном слайсе
    nums = append(nums, 6) // элемент не добавится в исходный слайс
}
```

# Копирование слайсов

Допустим, в вашей функции происходят изменения элементов, но вы не хотите затронуть входной слайс. В языке есть встроенная функция `func copy(dst, src []Type) int`, которая копирует слайс `src` в слайс `dst` и возвращает кол-во скопированных элементов:

```go
nums := []int{1,2,3,4,5}

// важно инициализировать слайс той же длины
numsCp := make([]int, len(nums))

copy(numsCp, nums)

fmt.Println(numsCp) // [1,2,3,4,5]
```

Почему мы не можем просто перезаписать слайс в другую переменную и изменять ее? Как и с функциями, при присваивании слайса к переменной, копируется только длина и вместимость, но массив передается по ссылке:

```go
nums := []int{1,2,3,4,5}

numsCp := nums

// исходный слайс nums тоже будет изменен
numsCp[0] = 10

fmt.Println(nums) // [10,2,3,4,5]
```

Существует распространенная ошибка, когда пытаются скопировать слайсы различной длины. В этом случае элементы, выходящие за рамки слайса `dst`, не будут скопированы:

```go
nums := []int{1, 2, 3, 4, 5}

// создали слайс с длиной 0
numsCp := make([]int, 0)

// при копировании в пустой слайс ничего не произойдет
copy(numsCp, nums)

fmt.Println(numsCp) // []
```

# Сортировка слайса

Сортировка массива — распространненая задача в программировании. Во всех языках существуют готовые решения для этой задачи, и Go — не исключение. Стандартный пакет **sort** предоставляет функции для сортировки:

```go
nums := []int{2,1,6,5,3,4}

sort.Slice(nums, func(i, j int) bool {
    return nums[i] < nums[j]
})

fmt.Println(nums) // [1 2 3 4 5 6]
```

Рассмотрим функцию `Slice(x interface{}, less func(i, j int) bool)`. В описании функции присутствует неизвестный тип данных `interface{}`. Понятие интерфейса будет рассмотренно в следующих модулях курса. Следует запомнить, что пустой интерфейс `interface{}` в Go означает тип данных, под который подходит любой другой тип.

Например:

```go
func Print(arg interface{}) {
    fmt.Println(arg)
}

func main() {
    Print("hello!")
    Print(123)
    Print([]int{1,5,10})
}
```

Вывод:

hello!
123
[1 5 10]

То есть в функцию `Slice(x interface{}, less func(i, j int) bool)` передается слайс любого типа данных, как первый аргумент. Вторым аргументом передается функция, которая берет элементы по индексу и определяет должен ли элемент по индексу `i` находиться перед элементом по индексу `j`.

"Под капотом" в функции **sort.Slice** используется быстрая сортировка. В пакете также присутствует сортировка вставками `sort.SliceStable`:

```go
nums := []int{2,1,6,5,3,4}

sort.SliceStable(nums, func(i, j int) bool {
    return nums[i] < nums[j]
})

fmt.Println(nums) // [1 2 3 4 5 6]
```

Выбор алгоритма зависит от набора и размера данных, архитектуры процессора, скорости доступа к памяти, то есть от многих факторов. Для большинства стандартных случаев используется `sort.Slice`, пока производительность или нестабильность алгоритма не станет "узким горлышком".