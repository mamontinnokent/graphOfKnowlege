Строки в Go объявляются с типом `string`:

```go
var s string = "hello"

// сокращенная запись
s := "hey"
```

Практически всегда для строк используются двойные кавычки. Однако они не подходят, когда нужно написать несколько строк. Для этого используются обратные кавычки:

```go
q := `
    SELECT *
    FROM person
    WHERE age > 18
`
```

Строки можно сравнивать операторами: `==`, `>`, `<`, `⇐`, `>=`. Если с `==` все понятно, то остальные вызывают вопросы. Строка №1 больше строки №2, если строка №2 меньше размером и является подстрокой строки №1. Это свойство часто используется при сортировке массива строк:

```go
"привет" == "привет" // true
"golang" > "go" // true
```

Базовые операции со строками в любом языке — это конкатенация и интерполяция. Конкатенация осуществляется с помощью знака `+`:

```go
"hello " + "world" // "hello world"
```

В Go нет привычной интерполяции, как в динамических языках. Она реализуется через форматирующую функцию `fmt.Sprintf()`:

```go
username := "Ivan"

greetings := fmt.Sprintf("hello, %s", username) // "hello, Ivan"
```

Узнать длину строки можно с помощью встроенной функции `len()`:

```go
len("go") // 2

// будьте внимательны! Функция считает кол-во байт, а не кол-во символов
len("го") // 4
```

# Строки и байты

Строки в Go — это иммутабельные массивы байт. Для стандартного компилятора Go внутренняя структура строки описана как:

```go
type _string struct {
    elements *byte // байты
    len      int   // кол-во байт
}
```

После инициализации строку нельзя изменить и такая иммутабельность позволяет избежать побочных эффектов в коде.

```go
s := "hello"
s[4] = "" // ошибка компиляции: cannot assign to s[4] (strings are immutable)
```

Стоит отметить, что тип данных `byte` — это алиас к типу `uint8` (0-255). Во-первых, потому что нужно абстрактно отличать типы в коде. Во-вторых, байты представляют ASCII символы, а в кодовой таблице ASCII символов 256 кодов:

```go
package main

import "fmt"

func main() {
    s := "hey"

    fmt.Println(s[0], s[1], s[2]) // 104 101 121

    fmt.Println(string(s[0]), string(s[1]), string(s[2])) // h e y
}
```

Большинство библиотечных функций работают со слайсами байт `[]byte` для производительности. Конвертация строки в слайс байт описывается в коде явно:

```go
package main

import "fmt"

func main() {
    s := "hey"
    bs := []byte(s)

    fmt.Println([]byte(s)) // [104 101 121]

    fmt.Println(string(bs)) // hey
}
```

Отдельные ASCII символы можно объявлять сразу с типом `byte`. Для этого нужно обернуть символ в одинарные кавычки и указать тип `byte`:

```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    asciiCh := byte('Z')
    asciiChStr := string(asciiCh)

    fmt.Println(reflect.TypeOf(asciiCh), asciiCh) // uint8 90

    fmt.Println(reflect.TypeOf(asciiChStr), asciiChStr) // string Z
}
```

# Обход строки

Так как строка — это массив байт, ее можно обойти с помощью цикла `for`:

```go
package main

import (
    "fmt"
)

func main() {
    s := "hello"
    for i := 0; i < len(s); i++ {
        fmt.Println(string(s[i]))
    }

}
```

Вывод:

h
e
l
l
o

Таким способом можно обойти только строки, состоящие из ASCII символов. Если строка содержит мультибайтовые символы, вывод будет некорректен:

```go
package main

import (
    "fmt"
)

func main() {
    s := "привет"
    for i := 0; i < len(s); i++ {
        fmt.Println(string(s[i]))
    }

}
```

Вывод проверьте сами в [**Go Playground**](https://go.dev/play/p/-G3ygH0rTIv)

# Стандартный пакет strings

Для работы со строками в Go существует стандартный пакет `strings`, который содержит основные функции. С некоторыми мы уже встречались в первом модуле (например `strings.ReplaceAll`). Теперь рассмотрим список самых часто встречающихся функций:

```go
import "strings"

// проверяет наличие подстроки в строке
strings.Contains("hello", "h") // true

// разбивает строку по Юникод символам или по переданному разделителю
strings.Split("hello", "") // ["h", "e", "l", "l", "o"]

// склеивает строки из слайса с разделителем
strings.Join([]string{"hello","world!"}, " ") // "hello world!"
```

Очень важная часть пакета `strings` — это `Builder`. Когда необходимо собрать большую строку по каким-то правилам, использование конкатенации — не лучшее решение, потому что каждая операция создает новую строку, что сильно влияет на производительность при большом количестве операций. Такая задача решается с помощью билдера:

```go
import "strings"

sb := &strings.Builder{}

sb.WriteString("hello")
sb.WriteString(" ")
sb.WriteString("world")

sb.String() // "hello world"
```

# Форматирование

В предыдущих уроках мы использовали пакет _fmt_ для вывода переменных или результатов функций:

```go
s := "hello world"

// печатает вывод на следующей строке
fmt.Println(s) // "hello world"
```

Пакет _fmt_ так же используется для форматирования строк. Плейсхолдеры разных типов данных в основном не отличаются от других языков:

```go
name := "Andy"

// подставляем строку
fmt.Sprintf("hello %s", name) // "hello Andy"

// число
fmt.Sprintf("there are %d kittens", 10) // "there are 10 kittens"

// логический тип
fmt.Sprintf("your story is %t", true) // "your story is true"
```

Так же существуют специализированные плейсхолдеры, которые преобразуют сложные структуры:

```go
package main

import (
    "fmt"
)

type Person struct {
    Name string
    Age  int
}

func main() {
    p := Person{Name: "Andy", Age: 18}

    // вывод значений структуры
    fmt.Println("simple struct:", p)

    // вывод названий полей и их значений
    fmt.Printf("detailed struct: %+v\n", p)

    // вывод названий полей и их значений в виде инициализации
    fmt.Printf("Golang struct: %#v\n", p)
}
```

Вывод:

simple struct: {Andy 18}
detailed struct: {Name:Andy Age:18}
Golang struct: main.Person{Name:"Andy", Age:18}